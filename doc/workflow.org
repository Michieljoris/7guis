* One more idea
One more idea: Only have three events: UPDATE, CREATE and DELETE. Extra info for CREATE event: table and id and time. Extra info for DELETE: table, id and whole (deleted) record. UPDATE extra info: table, id, column, old value, new value.  Then that's done. No more events to define. Then you can make more specific event by creating a rule like (and (= event :UPDATE (= table :dossier) (= id ANY) (= column :status) (= new-value "Completed")) and call that :dossier-status-completed. And use that to build more complex rules. I'm completely ignoring optimization, edge cases, action verifying, which events to feed into it. In any case, you can then define any event you want in a ui. People can define their own events.  And link them to actions, like sending email. Variables like table, id, new-value are passed to the action, so for instance they can be used in an email. If that's the action.


Events:


#+NAME: events
#+BEGIN_SRC clojure
{:type :update :table :dossier :id 1 :column :name :new-value "new-name" :old-value "old-name"}

{:type :update :table :checklist :id 1 :column :status :new-value "completed" :old-value "open" :updated-at "some-time"}

{:type :create :table :answer :id 1 :created-at "some-time"}
{:type :update :table :dossier :id 1 :column :status :new-value "completed" :old-value "open" :updated-at "some-time"} ;;!!!!!!!!!!!!11

{:type :update :table :answer :id 1 :column :value  :new-value "YES" :old-value "NO" :updated-at "some-time"}
{:type :update :table :remark :id 1 :column :value  :new-value "Some remark" :old-value "" :updated-at "some-time"}

{:type :create :table :checklist :id 100 :created-at "some-time"}
{:type :update :table :checklist :id 100 :column :name  :new-value "new checklist's name" :old-value nil :updated-at "some-time"}
;;more values set at creation

{:type :update :table :answer :id 1 :column :value  :new-value "NO" :old-value "YES" :updated-at "some-time"}



(and
 (and (= event :UPDATE) (= event.table :checklist) (= event.id '*) (= event.column :status) (= event.new-value "Completed") (= (event.entity.name "some name"))

)

)

(defn make-compound-event [type table id column new-value]
)
#+END_SRC

Hi. I've put something together, more for fun, but might be practical, It is able to take in a batch of events and evaluate rules. The rules can be as complicated as you wish, and there are only three events needed. In the little experimenting I did it seems to work ok. You have only update/create/delete events, you can then evaluate a statement about the state of the system at any moment in time. It's not needed to reconstruct the whole system, only the bits needed to evaluate the rule.  So it's kinda easy for instance to make a rule about change of status, but also for instance to for if status becames so and so AND  the name of the dossier is so and so. And with a bit more trickery you can can find out about the status of any other record as well. So also of related records. So the status of the parent dossier for instance. About performance I haven't worried too much. Every rule eval takes a few sql queries at the least for every event. Lots of rules, lots of events can add up. But the events db can have it's own sql server and data dir. And you could have a worker to evaluate the rules per group. Also can think of some more optimizations. Of course if you fleshed this out you might run into (big) problems. Don't know yet really.  But it's a nice thing to experiment with perhaps for proper workflow later on. If you like we can go through it next week somewhere? You thought about this stuff more than I probably by now, curious what you think. Anyway, back to ui and css and pixel shifting for me..
