#+TITLE: notes

* docs
** Bootup
*** dev
**** clj
When calling bin/dev-backend the last plugin (rebel) is configured in
resources/revold.edn under the :revolt.plugin/rebel.init-ns to load the clj.user
ns.
In clj.user a restart fn is defined that inits aum, inits a integrant system
with it and then calls (dev/go) on it. This kicks of all the init-key fns in the
various namespaces (db, server etc).
**** cljs
When starting figwheel (by either bin/dev-figwheel or space-m-" in Emacs) the
complier options in dev.cljs.edn get used to produce the js from cljs. The :main
options is set to cljs.user. This is the first file loaded in the frontend by
goog.require and all the dependent files are loaded after that. So cljs.user
should require app.frontend.core. This is enough to get the app going.


* Good to know
** jdbc, migrations, joplin and stch/sql
http://clojure-doc.org/articles/ecosystem/java_jdbc/using_ddl.html
https://github.com/stch-library/sql/blob/master/README.md
https://github.com/juxt/joplin/blob/master/README.md
** figwheel and emacs
https://docs.cider.mx/cider/cljs/figwheel.html
https://github.com/bhauman/figwheel-main/blob/master/src/figwheel/main/api.clj
https://github.com/bhauman/figwheel-main/blob/master/docs/docs/emacs.md

** Add emacs shortcuts for restart, reload namespaces etc
;; Fix docstring highlighting for `defsys`
(put 'defsys 'clojure-doc-string-elt 2)

;; The below functions allow you to control systemic from Emacs.
;; Personally, I have found binding them to keys to be very convenient.
(defun systemic/restart ()
  "Restarts all systemic systems"
  (interactive)
  (cider-interactive-eval "(systemic.core/restart!)"))

(defun systemic/start ()
  "Starts all systemic systems"
  (interactive)
  (cider-interactive-eval "(systemic.core/start!)"))

(defun systemic/stop ()
  "Stops all systemic systems"
  (interactive)
  (cider-interactive-eval "(systemic.core/stop!)"))
